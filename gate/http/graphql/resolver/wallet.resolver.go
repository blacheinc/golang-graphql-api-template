package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"

	"cendit.io/auth/logic"
	"cendit.io/auth/schema"
	"cendit.io/garage/function"
	"cendit.io/garage/logger"
	"cendit.io/garage/primer/constant"
	"cendit.io/garage/primer/enum"
	"cendit.io/garage/primer/typing"
	"cendit.io/gate/http/graphql/exception"
	"cendit.io/gate/http/graphql/model"
	"cendit.io/gate/http/rest/interceptor"
)

// AddWallet is the resolver for the addWallet field.
func (r *mutationResolver) AddWallet(ctx context.Context, input model.WalletInput) (model.RespondWithWallet, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: mutationResolver.addWallet with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "mutationResolver.AddWallet",
		Payload:     function.Stringify(input),
		Description: "made an action to add wallet",
		Error:       "",
		Status:      "",
	}
	act.Date()

	// access control
	auth, authObj, err := interceptor.Authorize(ctx)
	// we only expect a exception.Error here
	if err != nil && errors.As(err, &exception.Error{}) {
		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = err.(exception.Error).Status
		return nil, exception.MakeGraphQLError(ctx, err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})))
	}

	Wallet, err := logic.AddWallet(input, authObj.(schema.User))
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
			intrusion.Status = err.(exception.Error).Status
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})), function.Stringify(act)), nil
		}

		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = constant.CodeISE

		return exception.MakeSubgraphError(`Something went wrong while add your wallet Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error()), function.Stringify(act)), nil
	}

	// log activity
	act.Role = auth.Role
	act.By = auth.ID
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: mutationResolver.addWallet with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	var wallet model.Wallet
	function.Parse(Wallet, &wallet)

	return &model.ResponseWithWallet{
		Message: "Wallet added successfully.",
		Data:    &wallet,
	}, nil
}

// Wallets is the resolver for the wallets field.
func (r *queryResolver) Wallets(ctx context.Context, input model.WalletFilter) (model.RespondWithWallets, error) {
	panic(fmt.Errorf("not implemented: Wallets - wallets"))
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) UserWallets(ctx context.Context, input *model.WalletFilter) (model.RespondWithWallets, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: queryResolver.wallets with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "queryResolver.UserWallets",
		Payload:     "",
		Description: "made an action to add wallet",
		Error:       "",
		Status:      "",
	}
	act.Date()

	// access control
	auth, authObj, err := interceptor.Authorize(ctx)
	// we only expect a exception.Error here
	if err != nil && errors.As(err, &exception.Error{}) {
		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = err.(exception.Error).Status
		return nil, exception.MakeGraphQLError(ctx, err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})))
	}

	wallets, err := logic.Wallets(*input, authObj.(schema.User))
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
			intrusion.Status = err.(exception.Error).Status
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})), function.Stringify(act)), nil
		}

		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = constant.CodeISE

		return exception.MakeSubgraphError(`Something went wrong while fetching your wallets Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error()), function.Stringify(act)), nil
	}

	// log activity
	act.Role = auth.Role
	act.By = auth.ID
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: queryResolver.wallets with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	var ws []*model.Wallet

	function.Parse(wallets, &ws)

	return &model.ResponseWithWallets{
		Message: "Wallets retrieved.",
		Data:    ws,
	}, nil
}
