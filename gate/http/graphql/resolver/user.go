package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"

	"cendit.io/auth/repository"
	"cendit.io/garage/function"
	"cendit.io/garage/xiao"
	graphql1 "cendit.io/gate/http/graphql"
	"cendit.io/gate/http/graphql/model"
)

// User is the resolver for the user field.
func (r *addressResolver) User(ctx context.Context, obj *model.Address) (*model.User, error) {
	if obj != nil && obj.UserID != "" {
		user, err := repository.User().FindByMap(context.Background(), xiao.SQLMaps{
			WMaps: []xiao.SQLMap{
				{
					Map: map[string]interface{}{
						"id": obj.UserID,
					},
					JoinOperator:       xiao.And,
					ComparisonOperator: xiao.Equal,
				},
			},
		}, true)
		if err == nil {
			u := model.User{}

			function.Parse(user, &u)

			return &u, nil
		}
	}

	// this would work in a federated setup since Apollo Federation would handle the request
	// if obj != nil && obj.UserID != "" {
	// 	return &schema.User{
	// 		ID: obj.UserID,
	// 	}, nil
	// }
	return nil, nil
}

// Passcode is the resolver for the passcode field.
func (r *userResolver) Passcode(ctx context.Context, obj *model.User) (*string, error) {
	if obj != nil && obj.Passcode != nil && *obj.Passcode != "" {
		passcode := "passcode set"
		return &passcode, nil
	}
	return nil, nil
}

// Address is the resolver for the address field.
func (r *userResolver) Address(ctx context.Context, obj *model.User) (*model.Address, error) {
	if obj != nil && obj.ID != "" {
		address, err := repository.Address().FindByMap(context.Background(), xiao.SQLMaps{
			WMaps: []xiao.SQLMap{
				{
					Map: map[string]interface{}{
						"user_id": obj.ID,
					},
					JoinOperator:       xiao.And,
					ComparisonOperator: xiao.Equal,
				},
			},
		}, true)
		if err == nil {
			a := model.Address{}

			function.Parse(address, &a)

			return &a, nil
		}
	}

	// this would work in a federated setup since Apollo Federation would handle the request
	// if obj != nil && obj.ID != "" {
	// 	return &model.Address{
	// 		UserID: obj.ID,
	// 	}, nil
	// }
	return nil, nil
}

// SecuritySetting is the resolver for the security_setting field.
func (r *userResolver) SecuritySetting(ctx context.Context, obj *model.User) (*model.SecuritySetting, error) {
	if obj != nil && obj.ID != "" {
		setting, err := repository.SecuritySetting().FindByMap(context.Background(), xiao.SQLMaps{
			WMaps: []xiao.SQLMap{
				{
					Map: map[string]interface{}{
						"user_id": obj.ID,
					},
					JoinOperator:       xiao.And,
					ComparisonOperator: xiao.Equal,
				},
			},
		}, true)
		if err == nil {
			s := model.SecuritySetting{}

			function.Parse(setting, &s)

			return &s, nil
		}
	}

	return nil, nil
}

// Address returns graphql1.AddressResolver implementation.
func (r *Resolver) Address() graphql1.AddressResolver { return &addressResolver{r} }

// User returns graphql1.UserResolver implementation.
func (r *Resolver) User() graphql1.UserResolver { return &userResolver{r} }

type addressResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
