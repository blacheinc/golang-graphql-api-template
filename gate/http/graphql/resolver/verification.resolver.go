package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"

	"cendit.io/auth/logic"
	"cendit.io/auth/schema"
	"cendit.io/garage/function"
	"cendit.io/garage/logger"
	"cendit.io/garage/primer/constant"
	"cendit.io/garage/primer/enum"
	"cendit.io/garage/primer/typing"
	"cendit.io/gate/http/graphql/exception"
	"cendit.io/gate/http/graphql/model"
	"cendit.io/gate/http/rest/interceptor"
)

// EmailVerification is the resolver for the emailVerification field.
func (r *queryResolver) EmailVerification(ctx context.Context, input model.EmailVerificationInput) (model.Respond, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: queryResolver.EmailVerification with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "queryResolver.EmailVerification",
		Payload:     function.Stringify(input),
		Description: "made an action for email verification",
		Error:       "",
		Status:      "",
	}
	act.Date()

	message, err := logic.EmailVerification(input)
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
			intrusion.Status = err.(exception.Error).Status
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})), function.Stringify(act)), nil
		}

		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = constant.CodeISE

		return exception.MakeSubgraphError(`Something went wrong while verifying email! Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error())), nil
	}

	// log activity
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: queryResolver.EmailVerification with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	return &model.Response{Message: message}, nil
}

// EmailConfirmation is the resolver for the emailConfirmation field.
func (r *queryResolver) EmailConfirmation(ctx context.Context, input model.EmailConfirmationInput) (model.Respond, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: queryResolver.EmailConfirmation with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "queryResolver.EmailConfirmation",
		Payload:     function.Stringify(input),
		Description: "made an action for email confirmation",
		Error:       "",
		Status:      "",
	}
	act.Date()

	message, err := logic.EmailConfirmation(input)
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
			intrusion.Status = err.(exception.Error).Status
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})), function.Stringify(act)), nil
		}

		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = constant.CodeISE

		return exception.MakeSubgraphError(`Something went wrong while confirming email! Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error())), nil
	}

	// log activity
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: queryResolver.EmailConfirmation with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	return &model.Response{Message: message}, nil
}

// PhoneVerification is the resolver for the phoneVerification field.
func (r *queryResolver) PhoneVerification(ctx context.Context, input model.PhoneVerificationInput) (model.RespondWithAnything, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: queryResolver.PhoneVerification with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "queryResolver.PhoneVerification",
		Payload:     function.Stringify(input),
		Description: "made an action for phone number verification",
		Error:       "",
		Status:      "",
	}
	act.Date()

	reference, err := logic.PhoneVerification(input)
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{}))), nil
		}

		return exception.MakeSubgraphError(`Something went wrong while verifying phone number! Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error())), nil
	}

	// log activity
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: queryResolver.PhoneVerification with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	return &model.ResponseWithAnything{
		Message: "Verification code sent",
		Data:    reference,
	}, nil
}

// PhoneConfirmation is the resolver for the phoneConfirmation field.
func (r *queryResolver) PhoneConfirmation(ctx context.Context, input model.PhoneConfirmationInput) (model.RespondWithUser, error) {
	logger.GetLogger().Debug(fmt.Sprintf(`START :: [%v] :: queryResolver.PhoneConfirmation with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	act := schema.Activity{
		ID:          function.GenerateUUID(),
		Resolver:    "queryResolver.PhoneConfirmation",
		Payload:     function.Stringify(input),
		Description: "made an action for phone number confirmation",
		Error:       "",
		Status:      "",
	}
	act.Date()

	// access control
	_, authObj, err := interceptor.Authorize(ctx)
	// we only expect a exception.Error here
	if err != nil && errors.As(err, &exception.Error{}) {
		intrusion := ctx.Value(typing.CtxIntrusionKey{}).(*typing.Intrusion)
		intrusion.Status = err.(exception.Error).Status
		return nil, exception.MakeGraphQLError(ctx, err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{})))
	}

	user, err := logic.PhoneConfirmation(input, authObj.(schema.User))
	if err != nil {
		if errors.As(err, &exception.Error{}) {
			return exception.MakeSubgraphError(err.(exception.Error).Message, err.(exception.Error).Status, fmt.Sprintf(`[%v] :: {message}`, ctx.Value(typing.CtxTraceKey{}))), nil
		}

		return exception.MakeSubgraphError(`Something went wrong while confirming phone number! Please try again.`, constant.CodeISE, fmt.Sprintf(`[%v] :: {message} :: %s`, ctx.Value(typing.CtxTraceKey{}), err.Error())), nil
	}

	// log activity
	act.Role = user.Role
	act.By = user.ID
	act.Status = enum.Success
	if err := act.Insert(); err != nil {
		logger.GetLogger().Debug(`ACTIVITY LOG :: SAVE ERROR :: ` + err.Error())
	}

	logger.GetLogger().Debug(fmt.Sprintf(`END :: [%v] :: queryResolver.PhoneConfirmation with input: %+v`, ctx.Value(typing.CtxTraceKey{}), function.Stringify(input)))

	var u model.User
	function.Parse(user, &u)
	return &model.ResponseWithUser{
		Message: "Phone number verification successful",
		Data:    &u,
	}, nil
}
