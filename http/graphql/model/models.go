// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Respond interface {
	IsRespond()
}

type RespondWithBase interface {
	IsRespondWithBase()
}

type RespondWithTransaction interface {
	IsRespondWithTransaction()
}

type RespondWithTransactions interface {
	IsRespondWithTransactions()
}

type RespondWithUser interface {
	IsRespondWithUser()
}

type RespondWithUsers interface {
	IsRespondWithUsers()
}

type Attachment struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type AttachmentInput struct {
	Name string `json:"name"`
	URL  string `json:"url"`
}

type Base struct {
	// Base is a type describing an arbitrary set of keys.
	Exist *bool `json:"exist,omitempty"`
}

type Error struct {
	Message string `json:"message"`
	Code    string `json:"code"`
	Status  int    `json:"status"`
}

func (Error) IsRespond() {}

func (Error) IsRespondWithBase() {}

func (Error) IsRespondWithUser() {}

func (Error) IsRespondWithUsers() {}

func (Error) IsRespondWithTransaction() {}

func (Error) IsRespondWithTransactions() {}

type History struct {
	Act string `json:"act"`
	By  string `json:"by"`
	At  string `json:"at"`
}

type Item struct {
	Key      string  `json:"key"`
	Name     string  `json:"name"`
	Amount   float64 `json:"amount"`
	Quantity int     `json:"quantity"`
	Metadata *string `json:"metadata,omitempty"`
}

type Pagination struct {
	Page  int `json:"page"`
	Limit int `json:"limit"`
	Pages int `json:"pages"`
}

type Response struct {
	Message string `json:"message"`
}

func (Response) IsRespond() {}

type ResponseWithBase struct {
	Message string `json:"message"`
	Data    *Base  `json:"data,omitempty"`
}

func (ResponseWithBase) IsRespondWithBase() {}

type ResponseWithTransaction struct {
	Message string       `json:"message"`
	Data    *Transaction `json:"data,omitempty"`
}

func (ResponseWithTransaction) IsRespondWithTransaction() {}

type ResponseWithTransactions struct {
	Message string         `json:"message"`
	Data    []*Transaction `json:"data,omitempty"`
	// only returned when paginate is true
	Pagination *Pagination `json:"pagination,omitempty"`
}

func (ResponseWithTransactions) IsRespondWithTransactions() {}

type ResponseWithUser struct {
	Message string `json:"message"`
	Data    *User  `json:"data,omitempty"`
}

func (ResponseWithUser) IsRespondWithUser() {}

type ResponseWithUsers struct {
	Message string  `json:"message"`
	Data    []*User `json:"data,omitempty"`
	// only returned when paginate is true
	Pagination *Pagination `json:"pagination,omitempty"`
}

func (ResponseWithUsers) IsRespondWithUsers() {}

type Transaction struct {
	ID         string `json:"id"`
	SavingsID  string `json:"savings_id"`
	ProductID  string `json:"product_id"`
	CustomerID int    `json:"customer_id"`
	// initiator
	UserID        int                    `json:"user_id"`
	Type          ETransactionType       `json:"type"`
	Reference     string                 `json:"reference"`
	Currency      ECurrency              `json:"currency"`
	Gateway       EPaymentGateway        `json:"gateway"`
	Method        EPaymentMethod         `json:"method"`
	Paid          bool                   `json:"paid"`
	PaidAt        *time.Time             `json:"paid_at,omitempty"`
	Failed        bool                   `json:"failed"`
	FailedAt      *time.Time             `json:"failed_at,omitempty"`
	Cancelled     bool                   `json:"cancelled"`
	CancelledAt   *time.Time             `json:"cancelled_at,omitempty"`
	PaymentLink   *string                `json:"payment_link,omitempty"`
	InitialConfig map[string]interface{} `json:"initial_config,omitempty"`
	FinalConfig   map[string]interface{} `json:"final_config,omitempty"`
	History       []*History             `json:"history,omitempty"`
	Invoice       []*Item                `json:"invoice,omitempty"`
	SavingsAmount float64                `json:"savings_amount"`
	Amount        float64                `json:"amount"`
	PreBalance    float64                `json:"pre_balance"`
	PostBalance   float64                `json:"post_balance"`
	Remark        *string                `json:"remark,omitempty"`
	CreatedAt     *time.Time             `json:"created_at,omitempty"`
	UpdatedAt     *time.Time             `json:"updated_at,omitempty"`
}

type TransactionFilterInput struct {
	TransactionID *string `json:"transaction_id,omitempty"`
	SavingsID     *string `json:"savings_id,omitempty"`
	UserID        *int    `json:"user_id,omitempty"`
	ProductID     *string `json:"product_id,omitempty"`
	// organization id
	CustomerID *int              `json:"customer_id,omitempty"`
	Type       *ETransactionType `json:"type,omitempty"`
	Reference  *string           `json:"reference,omitempty"`
	Currency   *ECurrency        `json:"currency,omitempty"`
	Gateway    *EPaymentGateway  `json:"gateway,omitempty"`
	Method     *EPaymentMethod   `json:"method,omitempty"`
	Paid       *bool             `json:"paid,omitempty"`
	Failed     *bool             `json:"failed,omitempty"`
	Cancelled  *bool             `json:"cancelled,omitempty"`
	// searches by remark, reference, transaction_id
	Search *string `json:"search,omitempty"`
	Limit  *int    `json:"limit,omitempty"`
	Page   *int    `json:"page,omitempty"`
	Sort   *ESort  `json:"sort,omitempty"`
	// when true, returns page count and related info (try not to set to true always)
	Paginate *bool `json:"paginate,omitempty"`
}

type TransactionInput struct {
	AccountNumber string           `json:"account_number"`
	UserID        int              `json:"user_id"`
	Date          time.Time        `json:"date"`
	Type          ETransactionType `json:"type"`
	Amount        float64          `json:"amount"`
	Remark        *string          `json:"remark,omitempty"`
}

type User struct {
	ID        int       `json:"id"`
	OrgID     int       `json:"org_id"`
	Email     string    `json:"email"`
	Firstname string    `json:"firstname"`
	Lastname  string    `json:"lastname"`
	Phone     *string   `json:"phone,omitempty"`
	Gender    *string   `json:"gender,omitempty"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type WebhookInput struct {
	Tx        interface{}     `json:"tx"`
	Provider  EPaymentGateway `json:"provider"`
	Reference string          `json:"reference"`
}

type EAccountCreationType string

const (
	EAccountCreationTypeManual    EAccountCreationType = "MANUAL"
	EAccountCreationTypeAutomatic EAccountCreationType = "AUTOMATIC"
)

var AllEAccountCreationType = []EAccountCreationType{
	EAccountCreationTypeManual,
	EAccountCreationTypeAutomatic,
}

func (e EAccountCreationType) IsValid() bool {
	switch e {
	case EAccountCreationTypeManual, EAccountCreationTypeAutomatic:
		return true
	}
	return false
}

func (e EAccountCreationType) String() string {
	return string(e)
}

func (e *EAccountCreationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EAccountCreationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EAccountCreationType", str)
	}
	return nil
}

func (e EAccountCreationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ECurrency string

const (
	ECurrencyNgn ECurrency = "NGN"
	ECurrencyUsd ECurrency = "USD"
)

var AllECurrency = []ECurrency{
	ECurrencyNgn,
	ECurrencyUsd,
}

func (e ECurrency) IsValid() bool {
	switch e {
	case ECurrencyNgn, ECurrencyUsd:
		return true
	}
	return false
}

func (e ECurrency) String() string {
	return string(e)
}

func (e *ECurrency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ECurrency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ECurrency", str)
	}
	return nil
}

func (e ECurrency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EFrequency string

const (
	EFrequencyDaily     EFrequency = "DAILY"
	EFrequencyWeekly    EFrequency = "WEEKLY"
	EFrequencyMonthly   EFrequency = "MONTHLY"
	EFrequencyQuarterly EFrequency = "QUARTERLY"
	EFrequencyAnnually  EFrequency = "ANNUALLY"
	EFrequencyOneTime   EFrequency = "ONE_TIME"
	EFrequencyProRata   EFrequency = "PRO_RATA"
)

var AllEFrequency = []EFrequency{
	EFrequencyDaily,
	EFrequencyWeekly,
	EFrequencyMonthly,
	EFrequencyQuarterly,
	EFrequencyAnnually,
	EFrequencyOneTime,
	EFrequencyProRata,
}

func (e EFrequency) IsValid() bool {
	switch e {
	case EFrequencyDaily, EFrequencyWeekly, EFrequencyMonthly, EFrequencyQuarterly, EFrequencyAnnually, EFrequencyOneTime, EFrequencyProRata:
		return true
	}
	return false
}

func (e EFrequency) String() string {
	return string(e)
}

func (e *EFrequency) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EFrequency(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EFrequency", str)
	}
	return nil
}

func (e EFrequency) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EInterest string

const (
	EInterestSimple   EInterest = "SIMPLE"
	EInterestCompound EInterest = "COMPOUND"
	EInterestFixed    EInterest = "FIXED"
	EInterestVariable EInterest = "VARIABLE"
	EInterestTiered   EInterest = "TIERED"
)

var AllEInterest = []EInterest{
	EInterestSimple,
	EInterestCompound,
	EInterestFixed,
	EInterestVariable,
	EInterestTiered,
}

func (e EInterest) IsValid() bool {
	switch e {
	case EInterestSimple, EInterestCompound, EInterestFixed, EInterestVariable, EInterestTiered:
		return true
	}
	return false
}

func (e EInterest) String() string {
	return string(e)
}

func (e *EInterest) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EInterest(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EInterest", str)
	}
	return nil
}

func (e EInterest) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EPaymentGateway string

const (
	EPaymentGatewayPaystack    EPaymentGateway = "PAYSTACK"
	EPaymentGatewayFlutterwave EPaymentGateway = "FLUTTERWAVE"
	EPaymentGatewayWallet      EPaymentGateway = "WALLET"
)

var AllEPaymentGateway = []EPaymentGateway{
	EPaymentGatewayPaystack,
	EPaymentGatewayFlutterwave,
	EPaymentGatewayWallet,
}

func (e EPaymentGateway) IsValid() bool {
	switch e {
	case EPaymentGatewayPaystack, EPaymentGatewayFlutterwave, EPaymentGatewayWallet:
		return true
	}
	return false
}

func (e EPaymentGateway) String() string {
	return string(e)
}

func (e *EPaymentGateway) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EPaymentGateway(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EPaymentGateway", str)
	}
	return nil
}

func (e EPaymentGateway) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EPaymentMethod string

const (
	EPaymentMethodCard         EPaymentMethod = "CARD"
	EPaymentMethodBankTransfer EPaymentMethod = "BANK_TRANSFER"
	EPaymentMethodWallet       EPaymentMethod = "WALLET"
)

var AllEPaymentMethod = []EPaymentMethod{
	EPaymentMethodCard,
	EPaymentMethodBankTransfer,
	EPaymentMethodWallet,
}

func (e EPaymentMethod) IsValid() bool {
	switch e {
	case EPaymentMethodCard, EPaymentMethodBankTransfer, EPaymentMethodWallet:
		return true
	}
	return false
}

func (e EPaymentMethod) String() string {
	return string(e)
}

func (e *EPaymentMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EPaymentMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EPaymentMethod", str)
	}
	return nil
}

func (e EPaymentMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ESort string

const (
	ESortDesc ESort = "desc"
	ESortAsc  ESort = "asc"
)

var AllESort = []ESort{
	ESortDesc,
	ESortAsc,
}

func (e ESort) IsValid() bool {
	switch e {
	case ESortDesc, ESortAsc:
		return true
	}
	return false
}

func (e ESort) String() string {
	return string(e)
}

func (e *ESort) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ESort(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ESort", str)
	}
	return nil
}

func (e ESort) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type EStatus string

const (
	EStatusActive    EStatus = "ACTIVE"
	EStatusInactive  EStatus = "INACTIVE"
	EStatusDeleted   EStatus = "DELETED"
	EStatusPending   EStatus = "PENDING"
	EStatusCompleted EStatus = "COMPLETED"
)

var AllEStatus = []EStatus{
	EStatusActive,
	EStatusInactive,
	EStatusDeleted,
	EStatusPending,
	EStatusCompleted,
}

func (e EStatus) IsValid() bool {
	switch e {
	case EStatusActive, EStatusInactive, EStatusDeleted, EStatusPending, EStatusCompleted:
		return true
	}
	return false
}

func (e EStatus) String() string {
	return string(e)
}

func (e *EStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EStatus", str)
	}
	return nil
}

func (e EStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ETemplate string

const (
	// regular deposit with restricted withdrawals
	ETemplateRdwrw ETemplate = "RDWRW"
	// flexble regular deposit
	ETemplateFrd ETemplate = "FRD"
	// fixed deposit
	ETemplateFd ETemplate = "FD"
)

var AllETemplate = []ETemplate{
	ETemplateRdwrw,
	ETemplateFrd,
	ETemplateFd,
}

func (e ETemplate) IsValid() bool {
	switch e {
	case ETemplateRdwrw, ETemplateFrd, ETemplateFd:
		return true
	}
	return false
}

func (e ETemplate) String() string {
	return string(e)
}

func (e *ETemplate) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ETemplate(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ETemplate", str)
	}
	return nil
}

func (e ETemplate) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ETier string

const (
	ETierOne   ETier = "one"
	ETierTwo   ETier = "two"
	ETierThree ETier = "three"
)

var AllETier = []ETier{
	ETierOne,
	ETierTwo,
	ETierThree,
}

func (e ETier) IsValid() bool {
	switch e {
	case ETierOne, ETierTwo, ETierThree:
		return true
	}
	return false
}

func (e ETier) String() string {
	return string(e)
}

func (e *ETier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ETier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ETier", str)
	}
	return nil
}

func (e ETier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ETransactionType string

const (
	ETransactionTypeFunding    ETransactionType = "FUNDING"
	ETransactionTypeTransfer   ETransactionType = "TRANSFER"
	ETransactionTypeWithdrawal ETransactionType = "WITHDRAWAL"
	ETransactionTypeInterest   ETransactionType = "INTEREST"
)

var AllETransactionType = []ETransactionType{
	ETransactionTypeFunding,
	ETransactionTypeTransfer,
	ETransactionTypeWithdrawal,
	ETransactionTypeInterest,
}

func (e ETransactionType) IsValid() bool {
	switch e {
	case ETransactionTypeFunding, ETransactionTypeTransfer, ETransactionTypeWithdrawal, ETransactionTypeInterest:
		return true
	}
	return false
}

func (e ETransactionType) String() string {
	return string(e)
}

func (e *ETransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ETransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ETransactionType", str)
	}
	return nil
}

func (e ETransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
